type Org implements Profile {
  # Profile interface properties begin
  # a real type inheritance would be possible via: https://github.com/nicolasdao/graphql-s2s
  
  id: ID!
  slug: String!
  name: String
  actorId: String
  avatar: Image @relation(name: "AVATAR_IMAGE", direction: "OUT")
  deleted: Boolean
  disabled: Boolean
  location: Location @cypher(statement: "MATCH (this)-[:IS_IN]->(l:Location) RETURN l")
  locationName: String
  about: String
  socialMedia: [SocialMedia]! @relation(name: "OWNED_BY", direction: "IN")
  createdAt: String
  updatedAt: String

  followedBy: [User]! @relation(name: "FOLLOWS", direction: "IN")
  followedByCount: Int! @cypher(statement: "MATCH (this)<-[:FOLLOWS]-(r:User) RETURN COUNT(DISTINCT r)")
  # Is the currently logged in user following that user?
  followedByCurrentUser: Boolean! @cypher(
  statement: """
  MATCH (this)<-[:FOLLOWS]-(u:User { id: $cypherParams.currentUserId})
  RETURN COUNT(u) >= 1
  """
  )

  # Profile interface properties end


  # Wolle email: String! @cypher(statement: "MATCH (this)-[:PRIMARY_EMAIL]->(e:EmailAddress) RETURN e.email")
  # Wolle publicKey: String
  # Wolle role: UserGroup!
  # Wolle termsAndConditionsAgreedVersion: String
  # Wolle termsAndConditionsAgreedAt: String

  # Wolle invitedBy: User @relation(name: "INVITED", direction: "IN")
  # invited: [User] @relation(name: "INVITED", direction: "OUT")

  # Wolle locale: String
  # Wolle allowEmbedIframes: Boolean
  # showShoutsPublicly: Boolean
  # sendNotificationEmails: Boolean

  # Wolle friends: [User]! @relation(name: "FRIENDS", direction: "BOTH")
  # Wolle friendsCount: Int! @cypher(statement: "MATCH (this)<-[:FRIENDS]->(r:User) RETURN COUNT(DISTINCT r)")

  # following: [User]! @relation(name: "FOLLOWS", direction: "OUT")
  # followingCount: Int! @cypher(statement: "MATCH (this)-[:FOLLOWS]->(r:User) RETURN COUNT(DISTINCT r)")

  # inviteCodes: [InviteCode] @relation(name: "GENERATED", direction: "OUT")
  # redeemedInviteCode: InviteCode @relation(name: "REDEEMED", direction: "OUT")

  # isBlocked: Boolean! @cypher(
  # statement: """
  # MATCH (this)<-[:BLOCKED]-(user:User {id: $cypherParams.currentUserId})
  # RETURN COUNT(user) >= 1
  # """
  # )
  # blocked: Boolean! @cypher(
  # statement: """
  # MATCH (this)-[:BLOCKED]-(user:User {id: $cypherParams.currentUserId})
  # RETURN COUNT(user) >= 1
  # """
  # )

  # isMuted: Boolean! @cypher(
  # statement: """
  # MATCH (this)<-[:MUTED]-(user:User { id: $cypherParams.currentUserId})
  # RETURN COUNT(user) >= 1
  # """
  # )
  
  # contributions: [Post]! @relation(name: "WROTE", direction: "OUT")
  # contributionsCount: Int! @cypher(
  # statement: """
  # MATCH (this)-[:WROTE]->(r:Post)
  # WHERE NOT r.deleted = true AND NOT r.disabled = true
  # RETURN COUNT(r)
  # """
  # )

  # comments: [Comment]! @relation(name: "WROTE", direction: "OUT")
  # commentedCount: Int! @cypher(statement: "MATCH (this)-[:WROTE]->(:Comment)-[:COMMENTS]->(p:Post) WHERE NOT p.deleted = true AND NOT p.disabled = true RETURN COUNT(DISTINCT(p))")

  # shouted: [Post]! @relation(name: "SHOUTED", direction: "OUT")
  # shoutedCount: Int! @cypher(statement: "MATCH (this)-[:SHOUTED]->(r:Post) WHERE NOT r.deleted = true AND NOT r.disabled = true RETURN COUNT(DISTINCT r)")

  # categories: [Category] @relation(name: "CATEGORIZED", direction: "OUT")

  # badges: [Badge]! @relation(name: "REWARDED", direction: "IN")
  # badgesCount: Int! @cypher(statement: "MATCH (this)<-[:REWARDED]-(r:Badge) RETURN COUNT(r)")

  # Wolle emotions: [EMOTED]
}
